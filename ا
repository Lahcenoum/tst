import subprocess
import sys
import os
import random
import string
import sqlite3
import re
from datetime import datetime, date, timedelta
from telegram import Update, ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, CallbackQuery
from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes, MessageHandler, filters, CallbackQueryHandler, ConversationHandler
from telegram.constants import ParseMode
from telegram.error import BadRequest

# =================================================================================
# 1. ÿßŸÑÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ±ÿ¶Ÿäÿ≥Ÿäÿ© (Configuration)
# =================================================================================
TOKEN = "YOUR_TELEGRAM_BOT_TOKEN"
ADMIN_USER_ID = 5344028088 # ‚ö†Ô∏è ÿßÿ≥ÿ™ÿ®ÿØŸÑ Ÿáÿ∞ÿß ÿ®ŸÖÿπÿ±ŸÅ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ
ADMIN_CONTACT_INFO = "@YourAdminUsername" # ‚ö†Ô∏è ÿ∂ÿπ ŸáŸÜÿß ÿ±ÿßÿ®ÿ∑ ÿ≠ÿ≥ÿßÿ®ŸÉ ÿ£Ÿà ŸÖÿπÿ±ŸÅŸÉ

SCRIPT_PATH = '/usr/local/bin/create_ssh_user.sh'
DB_FILE = 'ssh_bot_users.db'

# --- ŸÇŸäŸÖ ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÜŸÇÿßÿ∑ ---
COST_PER_ACCOUNT = 4
REFERRAL_BONUS = 4
DAILY_LOGIN_BONUS = 1
INITIAL_POINTS = 2
JOIN_BONUS = 4
ACCOUNT_EXPIRY_DAYS = 2

# Channel and Group links and IDs (for force join)
REQUIRED_CHANNEL_ID = -1001932589296
REQUIRED_GROUP_ID = -1002218671728
CHANNEL_LINK = "https://t.me/FASTVPSVIP"
GROUP_LINK = "https://t.me/dgtliA"

if TOKEN == "YOUR_TELEGRAM_BOT_TOKEN" or not TOKEN:
    print("Fatal Error: Bot token is not set correctly in bot.py.")
    sys.exit(1)

# Conversation handler states
REDEEM_CODE = range(1)
CREATE_CODE_NAME, CREATE_CODE_POINTS, CREATE_CODE_USES = range(3)
(ADD_CHANNEL_NAME, ADD_CHANNEL_LINK, ADD_CHANNEL_ID, ADD_CHANNEL_POINTS) = range(4)


# =================================================================================
# 2. ÿØÿπŸÖ ÿßŸÑŸÑÿ∫ÿßÿ™ (Localization)
# =================================================================================
TEXTS = {
    'ar': {
        "welcome": "ÿ£ŸáŸÑÿßŸã ÿ®ŸÉ!\nÿßÿ≥ÿ™ÿÆÿØŸÖ ÿßŸÑÿ£ÿ≤ÿ±ÿßÿ± ÿ£ÿØŸÜÿßŸá ÿ£Ÿà ÿ∫Ÿäÿ± ŸÑÿ∫ÿ™ŸÉ ÿ®ÿßŸÑÿ£ŸÖÿ± /language.",
        "get_ssh_button": "üí≥ ÿ∑ŸÑÿ® ÿ≠ÿ≥ÿßÿ® ÿ¨ÿØŸäÿØ",
        "my_account_button": "üë§ ÿ≠ÿ≥ÿßÿ®Ÿä",
        "balance_button": "üí∞ ÿ±ÿµŸäÿØŸä",
        "referral_button": "üë• ÿßŸÑÿ•ÿ≠ÿßŸÑÿ©",
        "redeem_button": "üéÅ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØ ŸÉŸàÿØ",
        "daily_button": "‚òÄÔ∏è ŸÖŸÉÿßŸÅÿ£ÿ© ŸäŸàŸÖŸäÿ©",
        "rewards_button": "üì¢ ŸÇŸÜŸàÿßÿ™ ŸàŸÖŸÉÿßŸÅÿ¢ÿ™",
        "contact_admin_button": "üë®‚Äçüíª ÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿ£ÿØŸÖŸÜ",
        "contact_admin_info": "ŸÑŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿ£ÿØŸÖŸÜÿå Ÿäÿ±ÿ¨Ÿâ ŸÖÿ±ÿßÿ≥ŸÑÿ©: {contact_info}",
        "rewards_header": "ÿßŸÜÿ∂ŸÖ ÿ•ŸÑŸâ Ÿáÿ∞Ÿá ÿßŸÑŸÇŸÜŸàÿßÿ™ Ÿàÿßÿ≠ÿµŸÑ ÿπŸÑŸâ ŸÜŸÇÿßÿ∑!",
        "reward_claimed": "‚úÖ ÿ™ŸÖ ÿßŸÑÿ≠ÿµŸàŸÑ ÿπŸÑŸäŸáÿß",
        "verify_join_button": "‚úÖ ÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ",
        "reward_success": "üéâ ÿ±ÿßÿ¶ÿπ! ŸÑŸÇÿØ ÿ≠ÿµŸÑÿ™ ÿπŸÑŸâ {points} ŸÜŸÇÿ∑ÿ©.",
        "reward_fail": "‚ùå ŸÑŸÖ ÿ™ŸÜÿ∂ŸÖ ŸÑŸÑŸÇŸÜÿßÿ© ÿ®ÿπÿØ. ÿ≠ÿßŸàŸÑ ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ ÿ®ÿπÿØ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ.",
        "no_channels_available": "‚ÑπÔ∏è ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÖÿ™ÿßÿ≠ÿ© ŸÑŸÑŸÖŸÉÿßŸÅÿ¢ÿ™ ÿ≠ÿßŸÑŸäŸãÿß.",
        "admin_panel_header": "‚öôÔ∏è ŸÑŸàÿ≠ÿ© ÿ™ÿ≠ŸÉŸÖ ÿßŸÑÿ£ÿØŸÖŸÜ",
        "admin_manage_channels_button": " ÿ•ÿØÿßÿ±ÿ© ŸÇŸÜŸàÿßÿ™ ÿßŸÑŸÖŸÉÿßŸÅÿ¢ÿ™",
        "admin_manage_codes_button": " ÿ•ÿØÿßÿ±ÿ© ÿ£ŸÉŸàÿßÿØ ÿßŸÑŸáÿØÿßŸäÿß",
        "admin_create_code_button": "‚ûï ÿ•ŸÜÿ¥ÿßÿ° ŸÉŸàÿØ ÿ¨ÿØŸäÿØ",
        "admin_user_count_button": "üë§ ÿπÿØÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ",
        "admin_user_count_info": "üìä ÿßŸÑÿπÿØÿØ ÿßŸÑÿ•ÿ¨ŸÖÿßŸÑŸä ŸÑŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ: {count}",
        "admin_add_channel_button": "‚ûï ÿ•ÿ∂ÿßŸÅÿ© ŸÇŸÜÿßÿ©",
        "admin_remove_channel_button": "‚ûñ ÿ•ÿ≤ÿßŸÑÿ© ŸÇŸÜÿßÿ©",
        "admin_return_button": "‚¨ÖÔ∏è ÿπŸàÿØÿ©",
        "admin_add_channel_name_prompt": "ÿ£ÿ±ÿ≥ŸÑ ÿßÿ≥ŸÖ ÿßŸÑŸÇŸÜÿßÿ©:",
        "admin_add_channel_link_prompt": "ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ÿ±ÿßÿ®ÿ∑ ÿßŸÑŸÇŸÜÿßÿ© ÿßŸÑŸÉÿßŸÖŸÑ:",
        "admin_add_channel_id_prompt": "ÿ£ÿ±ÿ≥ŸÑ ŸÖÿπÿ±ŸÅ ÿßŸÑŸÇŸÜÿßÿ© ÿßŸÑÿ±ŸÇŸÖŸä (Ÿäÿ®ÿØÿ£ ÿ®ŸÄ -100):",
        "admin_add_channel_points_prompt": "ÿ£ÿÆŸäÿ±ÿßŸãÿå ÿ£ÿ±ÿ≥ŸÑ ÿπÿØÿØ ŸÜŸÇÿßÿ∑ ÿßŸÑŸÖŸÉÿßŸÅÿ£ÿ©:",
        "admin_channel_added_success": "‚úÖ ÿ™ŸÖ ÿ•ÿ∂ÿßŸÅÿ© ÿßŸÑŸÇŸÜÿßÿ© ÿ®ŸÜÿ¨ÿßÿ≠.",
        "admin_remove_channel_prompt": "ÿßÿÆÿ™ÿ± ÿßŸÑŸÇŸÜÿßÿ© ÿßŸÑÿ™Ÿä ÿ™ÿ±ŸäÿØ ÿ•ÿ≤ÿßŸÑÿ™Ÿáÿß:",
        "admin_channel_removed_success": "üóëÔ∏è ÿ™ŸÖ ÿ•ÿ≤ÿßŸÑÿ© ÿßŸÑŸÇŸÜÿßÿ© ÿ®ŸÜÿ¨ÿßÿ≠.",
        "invalid_input": "‚ùå ÿ•ÿØÿÆÿßŸÑ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ÿå Ÿäÿ±ÿ¨Ÿâ ÿßŸÑŸÖÿ≠ÿßŸàŸÑÿ© ŸÖÿ±ÿ© ÿ£ÿÆÿ±Ÿâ.",
        "operation_cancelled": "‚úÖ ÿ™ŸÖ ÿ•ŸÑÿ∫ÿßÿ° ÿßŸÑÿπŸÖŸÑŸäÿ©.",
        "creation_success": "‚úÖ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿ≠ÿ≥ÿßÿ®ŸÉ ÿ®ŸÜÿ¨ÿßÿ≠!\n\n**ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™:**\n```\n{details}\n```\n\n‚ö†Ô∏è **ŸÖŸÑÿßÿ≠ÿ∏ÿ©**: ÿ≥Ÿäÿ™ŸÖ ÿ≠ÿ∞ŸÅŸá ÿ™ŸÑŸÇÿßÿ¶ŸäŸãÿß ÿ®ÿπÿØ **{days} ÿ£ŸäÿßŸÖ**.",
        "account_details": "üè∑Ô∏è **ÿßÿ≥ŸÖ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖ:** `{username}`\nüóìÔ∏è **ÿ™ÿßÿ±ŸäÿÆ ÿßŸÜÿ™Ÿáÿßÿ° ÿßŸÑÿµŸÑÿßÿ≠Ÿäÿ©:** `{expiry}`",
        "choose_language": "ÿßÿÆÿ™ÿ± ŸÑÿ∫ÿ™ŸÉ ÿßŸÑŸÖŸÅÿ∂ŸÑÿ©:",
        "language_set": "‚úÖ ÿ™ŸÖ ÿ™ÿπŸäŸäŸÜ ÿßŸÑŸÑÿ∫ÿ© ÿ•ŸÑŸâ: {lang_name}",
        "force_join_prompt": "‚ùóÔ∏èŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™ÿå Ÿäÿ¨ÿ® ÿπŸÑŸäŸÉ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿ•ŸÑŸâ ŸÇŸÜÿßÿ™ŸÜÿß ŸàŸÖÿ¨ŸÖŸàÿπÿ™ŸÜÿß ÿ£ŸàŸÑÿßŸã.\n\nÿ®ÿπÿØ ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖÿå ÿßÿ∂ÿ∫ÿ∑ ÿπŸÑŸâ ÿ≤ÿ± 'ÿ™ÿ≠ŸÇŸÇÿ™'.",
        "force_join_channel_button": "üì¢ ÿßŸÜÿ∂ŸÖ ŸÑŸÑŸÇŸÜÿßÿ©",
        "force_join_group_button": "üë• ÿßŸÜÿ∂ŸÖ ŸÑŸÑŸÖÿ¨ŸÖŸàÿπÿ©",
        "force_join_verify_button": "‚úÖ ÿ™ÿ≠ŸÇŸÇÿ™",
        "force_join_success": "‚úÖ ÿ¥ŸÉÿ±Ÿãÿß ŸÑÿßŸÜÿ∂ŸÖÿßŸÖŸÉ! ŸäŸÖŸÉŸÜŸÉ ÿßŸÑÿ¢ŸÜ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ ÿßŸÑÿ®Ÿàÿ™.",
        "force_join_fail": "‚ùå ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿ™ÿ≠ŸÇŸÇ ŸÖŸÜ ÿßŸÜÿ∂ŸÖÿßŸÖŸÉ. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿßŸÜÿ∂ŸÖÿßŸÖŸÉ ŸÑŸÉŸÑŸäŸáŸÖÿß.",
        "join_bonus_awarded": "üéâ ŸÖŸÉÿßŸÅÿ£ÿ© ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ! ŸÑŸÇÿØ ÿ≠ÿµŸÑÿ™ ÿπŸÑŸâ **{bonus}** ŸÜŸÇÿ∑ÿ©.",
        "redeem_prompt": "Ÿäÿ±ÿ¨Ÿâ ÿ•ÿ±ÿ≥ÿßŸÑ ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ∞Ÿä ÿ™ÿ±ŸäÿØ ÿßÿ≥ÿ™ÿ±ÿØÿßÿØŸá.",
        "redeem_success": "üéâ ÿ™ŸáÿßŸÜŸäŸÜÿß! ŸÑŸÇÿØ ÿ≠ÿµŸÑÿ™ ÿπŸÑŸâ **{points}** ŸÜŸÇÿ∑ÿ©. ÿ±ÿµŸäÿØŸÉ ÿßŸÑÿ¢ŸÜ ŸáŸà **{new_balance}**.",
        "redeem_invalid_code": "‚ùå Ÿáÿ∞ÿß ÿßŸÑŸÉŸàÿØ ÿ∫Ÿäÿ± ÿµÿßŸÑÿ≠ ÿ£Ÿà ÿ∫Ÿäÿ± ŸÖŸàÿ¨ŸàÿØ.",
        "redeem_limit_reached": "‚ùå ŸÑŸÇÿØ ŸàÿµŸÑ Ÿáÿ∞ÿß ÿßŸÑŸÉŸàÿØ ÿ•ŸÑŸâ ÿßŸÑÿ≠ÿØ ÿßŸÑÿ£ŸÇÿµŸâ ŸÖŸÜ ÿßŸÑÿßÿ≥ÿ™ÿÆÿØÿßŸÖ.",
        "redeem_already_used": "‚ùå ŸÑŸÇÿØ ŸÇŸÖÿ™ ÿ®ÿßŸÑŸÅÿπŸÑ ÿ®ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑŸÉŸàÿØ.",
        "admin_settings_header": "‚öôÔ∏è ŸÑŸàÿ≠ÿ© ÿ™ÿ≠ŸÉŸÖ ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ®Ÿàÿ™",
        "admin_feature_points": "ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÜŸÇÿßÿ∑",
        "admin_feature_force_join": "ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑÿ•ÿ¨ÿ®ÿßÿ±Ÿä",
        "admin_feature_redeem": "ÿ£ŸÉŸàÿßÿØ ÿßŸÑŸÖŸÉÿßŸÅÿ¢ÿ™",
        "status_enabled": "üü¢ ŸÖŸÅÿπŸÑ",
        "status_disabled": "üî¥ ŸÖÿπÿ∑ŸÑ",
        "not_enough_points": "‚ö†Ô∏è ŸÑŸäÿ≥ ŸÑÿØŸäŸÉ ŸÜŸÇÿßÿ∑ ŸÉÿßŸÅŸäÿ©. ÿßŸÑÿ™ŸÉŸÑŸÅÿ© ŸáŸä **{cost}** ŸÜŸÇÿ∑ÿ©.",
        "no_accounts_found": "‚ÑπÔ∏è ŸÑŸÖ Ÿäÿ™ŸÖ ÿßŸÑÿπÿ´Ÿàÿ± ÿπŸÑŸâ ÿ£Ÿä ÿ≠ÿ≥ÿßÿ®ÿßÿ™ ŸÖÿ±ÿ™ÿ®ÿ∑ÿ© ÿ®ŸÉ.",
        "your_accounts": "üë§ ÿ≠ÿ≥ÿßÿ®ÿßÿ™ŸÉ ÿßŸÑŸÜÿ¥ÿ∑ÿ©:",
        "balance_info": "üí∞ ÿ±ÿµŸäÿØŸÉ ÿßŸÑÿ≠ÿßŸÑŸä ŸáŸà: **{points}** ŸÜŸÇÿ∑ÿ©.",
        "referral_info": "üë• ÿßÿØÿπŸè ÿ£ÿµÿØŸÇÿßÿ°ŸÉ ŸàÿßŸÉÿ≥ÿ® **{bonus}** ŸÜŸÇÿ∑ÿ© ŸÑŸÉŸÑ ÿµÿØŸäŸÇ ÿ¨ÿØŸäÿØ Ÿäÿ®ÿØÿ£ ÿßŸÑÿ®Ÿàÿ™ ÿπÿ®ÿ± ÿ±ÿßÿ®ÿ∑ŸÉ!\n\nüîó ÿ±ÿßÿ®ÿ∑ ÿßŸÑÿ•ÿ≠ÿßŸÑÿ© ÿßŸÑÿÆÿßÿµ ÿ®ŸÉ:\n`{link}`",
        "daily_bonus_claimed": "üéâ ŸÑŸÇÿØ ÿ≠ÿµŸÑÿ™ ÿπŸÑŸâ ŸÖŸÉÿßŸÅÿ£ÿ™ŸÉ ÿßŸÑŸäŸàŸÖŸäÿ©: **{bonus}** ŸÜŸÇÿ∑ÿ©! ÿ±ÿµŸäÿØŸÉ ÿßŸÑÿ¢ŸÜ ŸáŸà **{new_balance}**.",
        "daily_bonus_already_claimed": "‚ÑπÔ∏è ŸÑŸÇÿØ ÿ≠ÿµŸÑÿ™ ÿ®ÿßŸÑŸÅÿπŸÑ ÿπŸÑŸâ ŸÖŸÉÿßŸÅÿ£ÿ™ŸÉ ÿßŸÑŸäŸàŸÖŸäÿ©. ÿ™ÿπÿßŸÑ ÿ∫ÿØŸãÿß!",
        "creation_error": "‚ùå ÿ≠ÿØÿ´ ÿÆÿ∑ÿ£ ÿ£ÿ´ŸÜÿßÿ° ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑÿ≠ÿ≥ÿßÿ®. Ÿäÿ±ÿ¨Ÿâ ÿßŸÑÿ™ŸàÿßÿµŸÑ ŸÖÿπ ÿßŸÑÿ£ÿØŸÖŸÜ.",
        "admin_code_created": "‚úÖ ÿ™ŸÖ ÿ•ŸÜÿ¥ÿßÿ° ÿßŸÑŸÉŸàÿØ `{code}` ÿ®ŸÜÿ¨ÿßÿ≠. ŸäŸÖŸÜÿ≠ **{points}** ŸÜŸÇÿ∑ÿ© ŸàŸÖÿ™ÿßÿ≠ ŸÑŸÄ **{uses}** ŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ.",
        "admin_create_code_prompt_name": "ÿ£ÿ±ÿ≥ŸÑ ÿßÿ≥ŸÖ ÿßŸÑŸÉŸàÿØ ÿßŸÑÿ¨ÿØŸäÿØ (ŸÖÿ´ÿßŸÑ: WELCOME2025):",
        "admin_create_code_prompt_points": "ÿßŸÑÿ¢ŸÜ ÿ£ÿ±ÿ≥ŸÑ ÿπÿØÿØ ÿßŸÑŸÜŸÇÿßÿ∑ ÿßŸÑÿ™Ÿä ŸäŸÖŸÜÿ≠Ÿáÿß Ÿáÿ∞ÿß ÿßŸÑŸÉŸàÿØ:",
        "admin_create_code_prompt_uses": "ÿ£ÿÆŸäÿ±ÿßŸãÿå ÿ£ÿ±ÿ≥ŸÑ ÿπÿØÿØ ÿßŸÑŸÖÿ≥ÿ™ÿÆÿØŸÖŸäŸÜ ÿßŸÑÿ∞ŸäŸÜ ŸäŸÖŸÉŸÜŸáŸÖ ÿßÿ≥ÿ™ÿÆÿØÿßŸÖ Ÿáÿ∞ÿß ÿßŸÑŸÉŸàÿØ:",
    },
    'en': {
        # Full English translations can be added here
    },
}

# =================================================================================
# 3. ÿ•ÿØÿßÿ±ÿ© ŸÇÿßÿπÿØÿ© ÿßŸÑÿ®ŸäÿßŸÜÿßÿ™ (Database Management)
# =================================================================================
def init_db():
    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        cursor.execute('''CREATE TABLE IF NOT EXISTS ssh_accounts (id INTEGER PRIMARY KEY, telegram_user_id INTEGER, ssh_username TEXT, created_at TIMESTAMP)''')
        cursor.execute('''CREATE TABLE IF NOT EXISTS users (telegram_user_id INTEGER PRIMARY KEY, language_code TEXT DEFAULT 'ar', points INTEGER DEFAULT 0, referral_code TEXT, referred_by INTEGER, last_daily_claim DATE, join_bonus_claimed INTEGER DEFAULT 0)''')
        cursor.execute('''CREATE TABLE IF NOT EXISTS redeem_codes (code TEXT PRIMARY KEY, points INTEGER, max_uses INTEGER, current_uses INTEGER DEFAULT 0)''')
        cursor.execute('''CREATE TABLE IF NOT EXISTS redeemed_users (code TEXT, telegram_user_id INTEGER, PRIMARY KEY (code, telegram_user_id))''')
        cursor.execute('''CREATE TABLE IF NOT EXISTS settings (key TEXT PRIMARY KEY, value TEXT)''')
        cursor.execute('''CREATE TABLE IF NOT EXISTS reward_channels (channel_id INTEGER PRIMARY KEY, channel_link TEXT NOT NULL, reward_points INTEGER NOT NULL, channel_name TEXT NOT NULL)''')
        cursor.execute('''CREATE TABLE IF NOT EXISTS user_channel_rewards (telegram_user_id INTEGER, channel_id INTEGER, PRIMARY KEY (telegram_user_id, channel_id))''')
        
        default_settings = {'points_system': 'enabled', 'force_join': 'enabled', 'redeem_codes': 'enabled'}
        for key, value in default_settings.items():
            cursor.execute("INSERT OR IGNORE INTO settings (key, value) VALUES (?, ?)", (key, value))

        conn.commit()

def get_setting(key):
    with sqlite3.connect(DB_FILE) as conn:
        result = conn.execute("SELECT value FROM settings WHERE key = ?", (key,)).fetchone()
        return result[0] if result else None

def set_setting(key, value):
    with sqlite3.connect(DB_FILE) as conn:
        conn.execute("UPDATE settings SET value = ? WHERE key = ?", (value, key))
        conn.commit()

def is_feature_enabled(key):
    return get_setting(key) == 'enabled'

def get_user_language(user_id):
    with sqlite3.connect(DB_FILE) as conn:
        res = conn.execute("SELECT language_code FROM users WHERE telegram_user_id = ?", (user_id,)).fetchone()
        return res[0] if res else 'ar'

def set_user_language(user_id, lang_code):
    with sqlite3.connect(DB_FILE) as conn:
        conn.execute("UPDATE users SET language_code = ? WHERE telegram_user_id = ?", (lang_code, user_id))
        conn.commit()

def get_or_create_user(user_id, referred_by=None):
    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        if not cursor.execute("SELECT 1 FROM users WHERE telegram_user_id = ?", (user_id,)).fetchone():
            ref_code = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))
            cursor.execute("INSERT INTO users (telegram_user_id, points, referral_code, referred_by) VALUES (?, ?, ?, ?)", (user_id, INITIAL_POINTS, ref_code, referred_by))
            if referred_by and is_feature_enabled('points_system'):
                cursor.execute("UPDATE users SET points = points + ? WHERE telegram_user_id = ?", (REFERRAL_BONUS, referred_by))
            conn.commit()

def get_text(key, lang_code='ar'):
    return TEXTS.get(lang_code, TEXTS['ar']).get(key, key)

# =================================================================================
# 4. ÿØŸàÿßŸÑ ŸÖÿ≥ÿßÿπÿØÿ© (Helper Functions)
# =================================================================================
def escape_markdown_v2(text: str) -> str:
    escape_chars = r'\_*[]()~`>#+-=|{}.!'
    return re.sub(f'([{re.escape(escape_chars)}])', r'\\\1', text)

def generate_username():
    random_part = ''.join(random.choices(string.ascii_letters + string.digits, k=6))
    return f"botssh{random_part}"

def generate_password():
    random_part = ''.join(random.choices(string.ascii_letters + string.digits, k=3))
    return f"sshdatbot{random_part}"

async def check_membership(user_id: int, context: ContextTypes.DEFAULT_TYPE) -> bool:
    if not is_feature_enabled('force_join'): return True
    try:
        channel = await context.bot.get_chat_member(REQUIRED_CHANNEL_ID, user_id)
        group = await context.bot.get_chat_member(REQUIRED_GROUP_ID, user_id)
        return all(m.status in ['member', 'administrator', 'creator'] for m in [channel, group])
    except Exception:
        return False

# =================================================================================
# 5. ÿ£ŸàÿßŸÖÿ± ÿßŸÑÿ®Ÿàÿ™ (Bot Commands & Handlers)
# =================================================================================
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE, from_callback=False):
    user = update.effective_user
    message = update.message if not from_callback else update.callback_query.message
    
    referred_by = None
    if context.args:
        try:
            with sqlite3.connect(DB_FILE) as conn:
                res = conn.execute("SELECT telegram_user_id FROM users WHERE referral_code = ?", (context.args[0],)).fetchone()
                if res and res[0] != user.id: referred_by = res[0]
        except Exception: pass
    
    get_or_create_user(user.id, referred_by)
    lang_code = get_user_language(user.id)

    if not await check_membership(user.id, context):
        keyboard = [
            [InlineKeyboardButton(get_text('force_join_channel_button', lang_code), url=CHANNEL_LINK)],
            [InlineKeyboardButton(get_text('force_join_group_button', lang_code), url=GROUP_LINK)],
            [InlineKeyboardButton(get_text('force_join_verify_button', lang_code), callback_data='verify_join')],
        ]
        await message.reply_text(get_text('force_join_prompt', lang_code), reply_markup=InlineKeyboardMarkup(keyboard))
        return

    keyboard_layout = [
        [KeyboardButton(get_text('get_ssh_button', lang_code))],
        [KeyboardButton(get_text('balance_button', lang_code)), KeyboardButton(get_text('my_account_button', lang_code))],
        [KeyboardButton(get_text('daily_button', lang_code)), KeyboardButton(get_text('referral_button', lang_code))],
        [KeyboardButton(get_text('rewards_button', lang_code)), KeyboardButton(get_text('redeem_button', lang_code))],
        [KeyboardButton(get_text('contact_admin_button', lang_code))]
    ]
    reply_markup = ReplyKeyboardMarkup(keyboard_layout, resize_keyboard=True)
    await message.reply_text(get_text('welcome', lang_code), reply_markup=reply_markup)

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    get_or_create_user(user_id)
    if not await check_membership(user_id, context):
        await start(update, context)
        return

    text = update.message.text
    lang_code = get_user_language(user_id)
    
    button_map = {
        'get_ssh_button': get_ssh,
        'my_account_button': my_account,
        'balance_button': balance_command,
        'referral_button': referral_command,
        'daily_button': daily_command,
        'redeem_button': redeem_command,
        'rewards_button': rewards_command,
        'contact_admin_button': contact_admin_command,
    }

    for key, func in button_map.items():
        if text in [get_text(key, lang) for lang in TEXTS.keys() if lang in TEXTS]:
            await func(update, context)
            return

async def get_ssh(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    get_or_create_user(user_id)
    lang_code = get_user_language(user_id)
    
    if is_feature_enabled('points_system'):
        with sqlite3.connect(DB_FILE) as conn:
            points = conn.execute("SELECT points FROM users WHERE telegram_user_id = ?", (user_id,)).fetchone()[0]
        if points < COST_PER_ACCOUNT:
            await update.message.reply_text(get_text('not_enough_points', lang_code).format(cost=COST_PER_ACCOUNT))
            return

    username = generate_username()
    password = generate_password()
    command_to_run = [SCRIPT_PATH, username, password, str(ACCOUNT_EXPIRY_DAYS)]
    
    try:
        process = subprocess.run(command_to_run, capture_output=True, text=True, timeout=30, check=True)
        result = process.stdout
        with sqlite3.connect(DB_FILE) as conn:
            if is_feature_enabled('points_system'):
                conn.execute("UPDATE users SET points = points - ? WHERE telegram_user_id = ?", (COST_PER_ACCOUNT, user_id))
            conn.execute("INSERT INTO ssh_accounts (telegram_user_id, ssh_username, created_at) VALUES (?, ?, ?)", (user_id, username, datetime.now()))
            conn.commit()
        
        escaped_details = escape_markdown_v2(result)
        await update.message.reply_text(
            get_text('creation_success', lang_code).format(details=escaped_details, days=ACCOUNT_EXPIRY_DAYS),
            parse_mode=ParseMode.MARKDOWN_V2
        )
    except Exception as e:
        print(f"Error creating SSH account: {e}")
        await update.message.reply_text(get_text('creation_error', lang_code))

async def my_account(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    get_or_create_user(user_id)
    lang_code = get_user_language(user_id)
    with sqlite3.connect(DB_FILE) as conn:
        accounts = conn.execute("SELECT ssh_username FROM ssh_accounts WHERE telegram_user_id = ?", (user_id,)).fetchall()
    
    if not accounts:
        await update.message.reply_text(get_text('no_accounts_found', lang_code))
        return

    response = [get_text('your_accounts', lang_code)]
    for (username,) in accounts:
        try:
            expiry_output = subprocess.check_output(['/usr/bin/chage', '-l', username], text=True)
            expiry = next((line.split(':', 1)[1].strip() for line in expiry_output.split('\n') if "Account expires" in line), "Never")
            safe_username = escape_markdown_v2(username)
            safe_expiry = escape_markdown_v2(expiry)
            response.append(get_text('account_details', lang_code).format(username=safe_username, expiry=safe_expiry))
        except Exception as e:
            print(f"Could not get expiry for {username}: {e}")
    await update.message.reply_text("\n\n".join(response), parse_mode=ParseMode.MARKDOWN_V2)

async def balance_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    get_or_create_user(user_id)
    lang_code = get_user_language(user_id)
    with sqlite3.connect(DB_FILE) as conn:
        points = conn.execute("SELECT points FROM users WHERE telegram_user_id = ?", (user_id,)).fetchone()[0]
    await update.message.reply_text(get_text('balance_info', lang_code).format(points=points), parse_mode=ParseMode.MARKDOWN)

async def referral_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    get_or_create_user(user_id)
    lang_code = get_user_language(user_id)
    with sqlite3.connect(DB_FILE) as conn:
        ref_code = conn.execute("SELECT referral_code FROM users WHERE telegram_user_id = ?", (user_id,)).fetchone()[0]
    bot_username = (await context.bot.get_me()).username
    link = f"https://t.me/{bot_username}?start={ref_code}"
    await update.message.reply_text(get_text('referral_info', lang_code).format(bonus=REFERRAL_BONUS, link=link), parse_mode=ParseMode.MARKDOWN)

async def daily_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    get_or_create_user(user_id)
    lang_code = get_user_language(user_id)
    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        today = date.today()
        last_claim_str = cursor.execute("SELECT last_daily_claim FROM users WHERE telegram_user_id = ?", (user_id,)).fetchone()[0]
        if last_claim_str and date.fromisoformat(last_claim_str) == today:
            await update.message.reply_text(get_text('daily_bonus_already_claimed', lang_code))
            return
        cursor.execute("UPDATE users SET points = points + ?, last_daily_claim = ? WHERE telegram_user_id = ?", (DAILY_LOGIN_BONUS, today.isoformat(), user_id))
        conn.commit()
        new_balance = cursor.execute("SELECT points FROM users WHERE telegram_user_id = ?", (user_id,)).fetchone()[0]
        await update.message.reply_text(get_text('daily_bonus_claimed', lang_code).format(bonus=DAILY_LOGIN_BONUS, new_balance=new_balance))

async def contact_admin_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    lang_code = get_user_language(update.effective_user.id)
    await update.message.reply_text(get_text('contact_admin_info', lang_code).format(contact_info=ADMIN_CONTACT_INFO))

# --- Admin Panel & Features ---
async def admin_panel_command(update: Update | CallbackQuery, context: ContextTypes.DEFAULT_TYPE):
    if isinstance(update, CallbackQuery):
        user = update.from_user
        reply_func = update.edit_message_text
    else:
        user = update.effective_user
        reply_func = update.message.reply_text

    if user.id != ADMIN_USER_ID: return

    lang_code = get_user_language(user.id)
    keyboard = [
        [InlineKeyboardButton(get_text('admin_manage_channels_button', lang_code), callback_data='admin_manage_channels')],
        [InlineKeyboardButton(get_text('admin_manage_codes_button', lang_code), callback_data='admin_manage_codes')],
        [InlineKeyboardButton(get_text('admin_user_count_button', lang_code), callback_data='admin_user_count')]
    ]
    
    await reply_func(get_text('admin_panel_header', lang_code), reply_markup=InlineKeyboardMarkup(keyboard))


async def admin_panel_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if query.from_user.id != ADMIN_USER_ID: return

    data = query.data
    lang_code = get_user_language(query.from_user.id)

    if data == 'admin_user_count':
        with sqlite3.connect(DB_FILE) as conn:
            count = conn.execute("SELECT COUNT(*) FROM users").fetchone()[0]
        await query.edit_message_text(get_text('admin_user_count_info', lang_code).format(count=count), reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton(get_text('admin_return_button', lang_code), callback_data='admin_panel_main')]
        ]))
    
    elif data == 'admin_manage_channels':
        keyboard = [
            [InlineKeyboardButton(get_text('admin_add_channel_button', lang_code), callback_data='admin_add_channel_start')],
            [InlineKeyboardButton(get_text('admin_remove_channel_button', lang_code), callback_data='admin_remove_channel_start')],
            [InlineKeyboardButton(get_text('admin_return_button', lang_code), callback_data='admin_panel_main')]
        ]
        await query.edit_message_text("ÿ•ÿØÿßÿ±ÿ© ŸÇŸÜŸàÿßÿ™ ÿßŸÑŸÖŸÉÿßŸÅÿ¢ÿ™:", reply_markup=InlineKeyboardMarkup(keyboard))
    
    elif data == 'admin_manage_codes':
        keyboard = [
            [InlineKeyboardButton(get_text('admin_create_code_button', lang_code), callback_data='admin_create_code_start')],
            [InlineKeyboardButton(get_text('admin_return_button', lang_code), callback_data='admin_panel_main')]
        ]
        await query.edit_message_text("ÿ•ÿØÿßÿ±ÿ© ÿ£ŸÉŸàÿßÿØ ÿßŸÑŸáÿØÿßŸäÿß:", reply_markup=InlineKeyboardMarkup(keyboard))

    elif data == 'admin_panel_main':
        await admin_panel_command(query, context)


# --- Add/Remove Channel Logic ---
async def add_channel_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    await query.message.reply_text(get_text('admin_add_channel_name_prompt', 'ar'))
    return ADD_CHANNEL_NAME

async def add_channel_get_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['channel_name'] = update.message.text
    await update.message.reply_text(get_text('admin_add_channel_link_prompt', 'ar'))
    return ADD_CHANNEL_LINK

async def add_channel_get_link(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['channel_link'] = update.message.text
    await update.message.reply_text(get_text('admin_add_channel_id_prompt', 'ar'))
    return ADD_CHANNEL_ID

async def add_channel_get_id(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        context.user_data['channel_id'] = int(update.message.text)
        await update.message.reply_text(get_text('admin_add_channel_points_prompt', 'ar'))
        return ADD_CHANNEL_POINTS
    except ValueError:
        await update.message.reply_text(get_text('invalid_input', 'ar'))
        return ADD_CHANNEL_ID

async def add_channel_get_points(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        points = int(update.message.text)
        with sqlite3.connect(DB_FILE) as conn:
            conn.execute("INSERT OR REPLACE INTO reward_channels VALUES (?, ?, ?, ?)",
                         (context.user_data['channel_id'], context.user_data['channel_link'], points, context.user_data['channel_name']))
        await update.message.reply_text(get_text('admin_channel_added_success', 'ar'))
        context.user_data.clear()
        return ConversationHandler.END
    except ValueError:
        await update.message.reply_text(get_text('invalid_input', 'ar'))
        return ADD_CHANNEL_POINTS

async def remove_channel_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    with sqlite3.connect(DB_FILE) as conn:
        channels = conn.execute("SELECT channel_id, channel_name FROM reward_channels").fetchall()
    if not channels:
        await query.message.reply_text("ŸÑÿß ÿ™Ÿàÿ¨ÿØ ŸÇŸÜŸàÿßÿ™ ŸÑÿ•ÿ≤ÿßŸÑÿ™Ÿáÿß.")
        return
    keyboard = [[InlineKeyboardButton(name, callback_data=f"remove_c_{cid}")] for cid, name in channels]
    keyboard.append([InlineKeyboardButton(get_text('admin_return_button', 'ar'), callback_data='admin_manage_channels')])
    await query.edit_message_text(get_text('admin_remove_channel_prompt', 'ar'), reply_markup=InlineKeyboardMarkup(keyboard))

async def remove_channel_confirm(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    channel_id = int(query.data.split('_')[-1])
    with sqlite3.connect(DB_FILE) as conn:
        conn.execute("DELETE FROM reward_channels WHERE channel_id = ?", (channel_id,))
        conn.execute("DELETE FROM user_channel_rewards WHERE channel_id = ?", (channel_id,))
    await query.edit_message_text(get_text('admin_channel_removed_success', 'ar'))

async def cancel_conversation(update: Update, context: ContextTypes.DEFAULT_TYPE):
    lang_code = get_user_language(update.effective_user.id)
    await update.message.reply_text(get_text('operation_cancelled', lang_code))
    context.user_data.clear()
    return ConversationHandler.END

# --- Rewards Logic ---
async def rewards_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    get_or_create_user(user_id)
    lang_code = get_user_language(user_id)
    with sqlite3.connect(DB_FILE) as conn:
        all_channels = conn.execute("SELECT channel_id, channel_link, reward_points, channel_name FROM reward_channels").fetchall()
        claimed_ids = {row[0] for row in conn.execute("SELECT channel_id FROM user_channel_rewards WHERE telegram_user_id = ?", (user_id,))}
    if not all_channels:
        await update.message.reply_text(get_text('no_channels_available', lang_code))
        return
    keyboard = []
    for cid, link, points, name in all_channels:
        if cid in claimed_ids:
            button = InlineKeyboardButton(f"‚úÖ {name}", callback_data="dummy")
        else:
            button = InlineKeyboardButton(f"{name} (+{points} ŸÜŸÇÿ∑ÿ©)", url=link)
        keyboard.append([button])
        if cid not in claimed_ids:
             keyboard.append([InlineKeyboardButton(get_text('verify_join_button', lang_code), callback_data=f"verify_r_{cid}")])
    
    reply_func = update.callback_query.edit_message_text if hasattr(update, 'callback_query') and update.callback_query else update.message.reply_text
    await reply_func(get_text('rewards_header', lang_code), reply_markup=InlineKeyboardMarkup(keyboard))


async def verify_reward_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    lang_code = get_user_language(user_id)
    channel_id = int(query.data.split('_')[-1])
    try:
        member = await context.bot.get_chat_member(chat_id=channel_id, user_id=user_id)
        if member.status not in ['member', 'administrator', 'creator']:
            await query.answer(get_text('reward_fail', lang_code), show_alert=True)
            return
    except Exception as e:
        await query.answer(f"ÿÆÿ∑ÿ£: ŸÑÿß ŸäŸÖŸÉŸÜ ÿßŸÑÿ™ÿ≠ŸÇŸÇ. ÿ™ÿ£ŸÉÿØ ŸÖŸÜ ÿ£ŸÜ ÿßŸÑÿ®Ÿàÿ™ ŸÖÿ¥ÿ±ŸÅ ŸÅŸä ÿßŸÑŸÇŸÜÿßÿ©.", show_alert=True)
        return
    
    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        if cursor.execute("SELECT 1 FROM user_channel_rewards WHERE telegram_user_id = ? AND channel_id = ?", (user_id, channel_id)).fetchone():
            await query.answer("ŸÑŸÇÿØ ÿ≠ÿµŸÑÿ™ ÿπŸÑŸâ Ÿáÿ∞Ÿá ÿßŸÑŸÖŸÉÿßŸÅÿ£ÿ© ÿ®ÿßŸÑŸÅÿπŸÑ.", show_alert=True)
            return
        points = cursor.execute("SELECT reward_points FROM reward_channels WHERE channel_id = ?", (channel_id,)).fetchone()[0]
        cursor.execute("UPDATE users SET points = points + ? WHERE telegram_user_id = ?", (points, user_id))
        cursor.execute("INSERT INTO user_channel_rewards (telegram_user_id, channel_id) VALUES (?, ?)", (user_id, channel_id))
        conn.commit()
    await query.answer(get_text('reward_success', lang_code).format(points=points), show_alert=True)
    await rewards_command(query, context)

# --- Redeem Code Conversation ---
async def redeem_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if not is_feature_enabled('redeem_codes'): return
    await update.message.reply_text(get_text('redeem_prompt', get_user_language(update.effective_user.id)))
    return REDEEM_CODE

async def process_redeem_code(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    get_or_create_user(user_id)
    lang_code = get_user_language(user_id)
    code = update.message.text
    with sqlite3.connect(DB_FILE) as conn:
        cursor = conn.cursor()
        code_data = cursor.execute("SELECT points, max_uses, current_uses FROM redeem_codes WHERE code = ?", (code,)).fetchone()
        if not code_data:
            await update.message.reply_text(get_text('redeem_invalid_code', lang_code))
            return ConversationHandler.END
        points, max_uses, current_uses = code_data
        if current_uses >= max_uses:
            await update.message.reply_text(get_text('redeem_limit_reached', lang_code))
            return ConversationHandler.END
        if cursor.execute("SELECT 1 FROM redeemed_users WHERE code = ? AND telegram_user_id = ?", (code, user_id)).fetchone():
            await update.message.reply_text(get_text('redeem_already_used', lang_code))
            return ConversationHandler.END
        cursor.execute("UPDATE users SET points = points + ? WHERE telegram_user_id = ?", (points, user_id))
        cursor.execute("UPDATE redeem_codes SET current_uses = current_uses + 1 WHERE code = ?", (code,))
        cursor.execute("INSERT INTO redeemed_users (code, telegram_user_id) VALUES (?, ?)", (code, user_id))
        conn.commit()
        new_balance = cursor.execute("SELECT points FROM users WHERE telegram_user_id = ?", (user_id,)).fetchone()[0]
        await update.message.reply_text(get_text('redeem_success', lang_code).format(points=points, new_balance=new_balance))
    return ConversationHandler.END

# --- Create Code Conversation (Admin) ---
async def create_code_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    lang_code = get_user_language(query.from_user.id)
    await query.message.reply_text(get_text('admin_create_code_prompt_name', lang_code))
    return CREATE_CODE_NAME

async def receive_code_name(update: Update, context: ContextTypes.DEFAULT_TYPE):
    context.user_data['code_name'] = update.message.text
    lang_code = get_user_language(update.effective_user.id)
    await update.message.reply_text(get_text('admin_create_code_prompt_points', lang_code))
    return CREATE_CODE_POINTS

async def receive_code_points(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        context.user_data['code_points'] = int(update.message.text)
        lang_code = get_user_language(update.effective_user.id)
        await update.message.reply_text(get_text('admin_create_code_prompt_uses', lang_code))
        return CREATE_CODE_USES
    except ValueError:
        lang_code = get_user_language(update.effective_user.id)
        await update.message.reply_text(get_text('invalid_input', lang_code))
        return CREATE_CODE_POINTS

async def receive_code_uses(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        uses = int(update.message.text)
        name = context.user_data['code_name']
        points = context.user_data['code_points']
        lang_code = get_user_language(update.effective_user.id)

        with sqlite3.connect(DB_FILE) as conn:
            conn.execute("INSERT OR REPLACE INTO redeem_codes (code, points, max_uses) VALUES (?, ?, ?)", (name, points, uses))
            conn.commit()

        await update.message.reply_text(get_text('admin_code_created', lang_code).format(code=name, points=points, uses=uses))
        context.user_data.clear()
        return ConversationHandler.END
    except ValueError:
        lang_code = get_user_language(update.effective_user.id)
        await update.message.reply_text(get_text('invalid_input', lang_code))
        return CREATE_CODE_USES

# --- Settings Command ---
async def settings_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    if user.id != ADMIN_USER_ID: return
    
    lang_code = get_user_language(user.id)
    features = {'points_system': 'ŸÜÿ∏ÿßŸÖ ÿßŸÑŸÜŸÇÿßÿ∑', 'force_join': 'ÿßŸÑÿßŸÜÿ∂ŸÖÿßŸÖ ÿßŸÑÿ•ÿ¨ÿ®ÿßÿ±Ÿä', 'redeem_codes': 'ÿ£ŸÉŸàÿßÿØ ÿßŸÑŸÖŸÉÿßŸÅÿ¢ÿ™'}
    keyboard = []
    for key, name in features.items():
        status = "üü¢" if is_feature_enabled(key) else "üî¥"
        keyboard.append([InlineKeyboardButton(f"{name}: {status}", callback_data=f"toggle_{key}")])
    
    reply_func = update.callback_query.edit_message_text if hasattr(update, 'callback_query') and update.callback_query else update.message.reply_text
    await reply_func("‚öôÔ∏è ŸÑŸàÿ≠ÿ© ÿ™ÿ≠ŸÉŸÖ ÿ•ÿπÿØÿßÿØÿßÿ™ ÿßŸÑÿ®Ÿàÿ™", reply_markup=InlineKeyboardMarkup(keyboard))

async def toggle_setting_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    if query.from_user.id != ADMIN_USER_ID: return
    key = query.data.split('_')[1]
    new_status = 'disabled' if is_feature_enabled(key) else 'enabled'
    set_setting(key, new_status)
    await settings_command(query, context) # Refresh

# --- Language Command ---
async def language_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("üá¨üáß English", callback_data='set_lang_en')],
        [InlineKeyboardButton("üá∏üá¶ ÿßŸÑÿπÿ±ÿ®Ÿäÿ©", callback_data='set_lang_ar')],
    ]
    await update.message.reply_text(get_text('choose_language', get_user_language(update.effective_user.id)), reply_markup=InlineKeyboardMarkup(keyboard))

async def set_language_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()
    lang_code = query.data.split('_')[-1]
    set_user_language(query.from_user.id, lang_code)
    lang_map = {'en': 'English', 'ar': 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©'}
    await query.edit_message_text(text=get_text('language_set', lang_code).format(lang_name=lang_map.get(lang_code)))
    await start(update, context, from_callback=True)

async def verify_join_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    user_id = query.from_user.id
    lang_code = get_user_language(user_id)
    if await check_membership(user_id, context):
        with sqlite3.connect(DB_FILE) as conn:
            cursor = conn.cursor()
            if not cursor.execute("SELECT join_bonus_claimed FROM users WHERE telegram_user_id = ?", (user_id,)).fetchone()[0]:
                cursor.execute("UPDATE users SET points = points + ?, join_bonus_claimed = 1 WHERE telegram_user_id = ?", (JOIN_BONUS, user_id))
                conn.commit()
                await query.answer(get_text('join_bonus_awarded', lang_code).format(bonus=JOIN_BONUS), show_alert=True)
        await query.answer(get_text('force_join_success', lang_code))
        await query.delete_message()
        await start(update, context, from_callback=True)
    else:
        await query.answer(get_text('force_join_fail', lang_code), show_alert=True)

# =================================================================================
# 6. ŸÜŸÇÿ∑ÿ© ÿßŸÜÿ∑ŸÑÿßŸÇ ÿßŸÑÿ®Ÿàÿ™ (Main Entry Point)
# =================================================================================
def main():
    print("Initializing database...")
    init_db()
    print("Building bot application...")
    app = ApplicationBuilder().token(TOKEN).build()

    # Conversation Handlers
    add_channel_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(add_channel_start, pattern='^admin_add_channel_start$')],
        states={
            ADD_CHANNEL_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_channel_get_name)],
            ADD_CHANNEL_LINK: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_channel_get_link)],
            ADD_CHANNEL_ID: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_channel_get_id)],
            ADD_CHANNEL_POINTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, add_channel_get_points)],
        },
        fallbacks=[CommandHandler('cancel', cancel_conversation)]
    )
    
    redeem_conv = ConversationHandler(
        entry_points=[CommandHandler("redeem", redeem_command)],
        states={REDEEM_CODE: [MessageHandler(filters.TEXT & ~filters.COMMAND, process_redeem_code)]},
        fallbacks=[CommandHandler('cancel', cancel_conversation)]
    )

    create_code_conv = ConversationHandler(
        entry_points=[CallbackQueryHandler(create_code_start, pattern='^admin_create_code_start$')],
        states={
            CREATE_CODE_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_code_name)],
            CREATE_CODE_POINTS: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_code_points)],
            CREATE_CODE_USES: [MessageHandler(filters.TEXT & ~filters.COMMAND, receive_code_uses)],
        },
        fallbacks=[CommandHandler('cancel', cancel_conversation)]
    )

    # Add all handlers
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("admin", admin_panel_command))
    app.add_handler(CommandHandler("settings", settings_command))
    app.add_handler(CommandHandler("language", language_command))
    
    app.add_handler(add_channel_conv)
    app.add_handler(redeem_conv)
    app.add_handler(create_code_conv)

    app.add_handler(CallbackQueryHandler(admin_panel_callback, pattern='^admin_'))
    app.add_handler(CallbackQueryHandler(remove_channel_start, pattern='^admin_remove_channel_start$'))
    app.add_handler(CallbackQueryHandler(remove_channel_confirm, pattern='^remove_c_'))
    app.add_handler(CallbackQueryHandler(verify_reward_callback, pattern='^verify_r_'))
    app.add_handler(CallbackQueryHandler(verify_join_callback, pattern='^verify_join$'))
    app.add_handler(CallbackQueryHandler(set_language_callback, pattern='^set_lang_'))
    app.add_handler(CallbackQueryHandler(toggle_setting_callback, pattern='^toggle_'))
    app.add_handler(CallbackQueryHandler(lambda u,c: u.callback_query.answer(), pattern='^dummy$'))
    
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))

    print("Bot is running...")
    app.run_polling()

if __name__ == '__main__':
    main()
